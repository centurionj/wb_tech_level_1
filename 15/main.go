/*
К каким негативным последствиям может привести данный фрагмент кода, и как
это исправить? Приведите корректный пример реализации.

var justString string
func someFunc() {
	v := createHugeString(1 << 10)
	justString = v[:100]
}
	func main() {
	someFunc()
}
*/

/*
Когда создается подстрока из большой строки, ориг строка остается в памяти до тех пор, пока подстрока будет больше не нужна.
Это происходит потому, что в языке Go строки и их срезы используют одну и ту же память. Значит, когда создается подстрока
из строки, эта большая строка остается доступной в памяти, так как на нее ссылается подстрока.
Как вывод, что если строка огромная, то может привести к большому потреблению памяти
*/

package main

import (
	"bytes"
	"fmt"
)

// Функция для создания большого буфера и получения подстроки
func createHugeBuffer(size int) *bytes.Buffer {
	return bytes.NewBuffer(make([]byte, size))
}

func someFunc() {
	hugeBuffer := createHugeBuffer(1 << 10) // Создает буфер размером 1024 байта
	// Вместо создания большой строки сначала, сразу создаем подстроку
	justString := hugeBuffer.String()[:100] // Берем подстроку из первых 100 байт
	fmt.Println("Substring length:", len(justString))
}

func main() {
	someFunc()
}
