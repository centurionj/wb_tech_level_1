# Ответы на устные вопросы

### Вопрос 1
#### Какой самый эффективный способ конкатенации строк?
Я считаю, что самый эффективный способ конкатенации строк, - это использование strings.Builder из пакета strings. 
Тк используется 1 буфер для хранения промежуточных строк, а значит и кол-во выделяемойц памяти мало, это приводит 
к уменьшению нагрузки на сборщик мусора.

### Вопрос 2
#### Что такое интерфейсы, как они применяются в Go?
Интерфейс - это контракт, который позволяет определить набор методов, которые должны быть реализованы типами. 
Интерфейсы в Go предоставляют способ определения поведения, а не данных. Любой тип, который реализует все методы интерфейса, 
автоматически считается реализацией этого интерфейса.

Интерфейсы позволяют писать более общий и гибкий код. Интерфейсы позволяют определить поведение без привязки к реализации.
Код, с интерфейсами, может работать с любыми типами, которые их реализуют. Облегчают процесс накписания тестов (модульных),
тк можно передавать в функции и методы моки (mock-объекты).

### Вопрос 3
#### Чем отличаются RWMutex от Mutex?
Обе блокировки потоков находятся в пакете sync, и используются для управления доступом к ресурсам в многопоточных программах.
Mutex позволяет ограничить доступ к ресурсу только одному потоку в любой момент времени. В то время как RWMutex позволяет множественным 
потокам одновременно читать данные (RLock), но только одному потоку писать данные (Lock).

### Вопрос 4
#### Чем отличаются буферизированные и не буферизированные каналы?
Небуф каналы требуют синхронизации между отправителем и получателем. Отправляющая горутина будет заблокирована, пока другая 
горутина не получит данные из канала, и наоборот. Буф каналы имеют емкость (капасити - размер буфера) поэтому отправляющая 
горутина продолжает выполнение до тех пор, пока буфер не заполнен; получающие получают пока буфер не станет пустым.

### Вопрос 5
#### Какой размер у структуры struct{}{}?
Пустая структура struct{}{} не занимает памяти, потому что в ней нет данных, поэтому ее размер равен 0.

### Вопрос 6
#### Есть ли в Go перегрузка методов или операторов?
В Go ет перегрузки методов или операторов. С версии 1.18 была добавлена поддержка generics. Они позволяют создавать 
более гибкие и переиспользуемые функции и типы, что делает возможным написание кода, который может работать с различными 
типами данных, сохраняя при этом строгую типизацию.

### Вопрос 7
#### В какой последовательности будут выведены элементы map[int]int?
```azure
Пример:
    
m[0]=1
m[1]=124
m[2]=281
```
Порядок вывода элементов из мапы не определен, поэтому при каждом старте программы результат может меняться.

### Вопрос 8
#### В чем разница make и new?

make:
- Используется только для slice, map, chan
- Входящие параметры включают тип и размер.
- Возвращается сам тип.
- Выделить место в памяти и инициализировать.

nеw:
- Любая структура, включая slice, map, chan.
- Допускается только один параметр типа, без размера
- Возврат - это указатель типа
- Выделить место в памяти без инициализации

### Вопрос 9
#### Сколько существует способов задать переменную типа slice или map?
slice:
- С помощью литерала среза
```azure
s := []int{1, 2, 3}
```
- С помощью функции make
```azure
s := make([]int, 3, 5)
```
- С помощью new
```azure
s := new([]int) // Создаётся указатель на нулевой срез
*s = make([]int, 5) // Инициализация среза
```
- Инициализация пустого среза
```azure
var s []int // Нулевой срез (nil)
s = []int{} // Пустой срез
```
- С помощью существующего массива
```azure
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4]
```

map:
- С помощью литерала мапы
```azure
m := map[string]int{"one": 1, "two": 2}
```
- С помощью функции make
```azure
m := make(map[string]int, 5)
```
- С помощью new
```azure
m := new(map[string]int)
*m = make(map[string]int)
```
- Инициализация пустой мапы
```azure
var m map[string]int // Нулевая карта (nil)
m = map[string]int{}
```

### Вопрос 10
#### Что выведет данная программа и почему?
```azure
func update(p *int) {
    b := 2
    p = &b
}
    
func main() {
    var (
        a = 1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```
Данная программа не изменит значение переменной p, тк все аргументы передаются в функции по значению, а не по ссылке. И 
когда передаем указатель p в функцию update сам указатель копируется, а не сам объект на который он ссылается.  Внутри 
update меняется локальная копия указателя p, но это никак не влияет на оригинальный указатель в функции main. Поэтому вывод 1 1

### Вопрос 11
#### Что выведет данная программа и почему?
```azure
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
    wg.Wait()
    fmt.Println("exit")
}
```
Программа завершгится с дедлоком, так как ожидающая группа передаетсяя в горутину не по ссылке а по значению.

### Вопрос 12
#### Что выведет данная программа и почему?
```azure
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
        
    fmt.Println(n)
}
```
Выведется внешняя переменная n равная 0. Тк внутри условия создается локальная переменная n со значением 1. 

### Вопрос 13
#### Что выведет данная программа и почему?
```azure
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
    }
    
func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
Выведется [100 2 3 4 5]. Тк срезы передаются по значению, но под капотом содержат указатель на массив. Поэтому изменится
элемент с индексом 0 с 1 на 100. При изменении длины среза, менятеся емкость и длина, а значит и указатель будет ссылаться 
уже на другой массив и оригинальный массив a останется без изменений.

### Вопрос 14
#### Что выведет данная программа и почему?
```azure
func main() {
    slice := []string{"a", "a"}
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    
    fmt.Print(slice)
}
```
Аналогично заданию 13.
